#!/usr/bin/env node
import { mkdir, writeFile, rm } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const here = path.dirname(fileURLToPath(import.meta.url));
const root = path.resolve(here, "..");
const fixturesRoot = path.join(root, "benchmarks", "fixtures");

const PACKAGE_NAMES = [
  "react","react-dom","next","typescript","axios","zod","vite","vitest","eslint","prettier",
  "lodash","express","commander","chalk","glob","rimraf","date-fns","dayjs","zustand","immer",
  "rxjs","inquirer","ora","undici","ws","debug","dotenv","cross-env","concurrently","esbuild",
  "tsup","tsx","typescript-eslint","eslint-config-prettier","eslint-plugin-import","eslint-plugin-react","eslint-plugin-react-hooks","eslint-plugin-jsx-a11y","postcss","autoprefixer",
  "tailwindcss","clsx","cac","kleur","prompts","boxen","meow","pino","winston","yargs",
  "listr2","execa","nanoid","semver","yaml","toml","ajv","zod-validation-error","ms","mime",
  "fast-glob","chokidar","picocolors","open","tar","node-fetch","superjson","strip-ansi","string-width","pretty-ms",
  "uuid","jsdom","happy-dom","msw","supertest","playwright","puppeteer","knip","npm-check-updates","taze",
  "pnpm","npm-package-arg","pacote","libnpmpack","npm-registry-fetch","@types/node","@types/react","@types/react-dom","@types/express","@types/ws",
  "@types/lodash","@types/js-yaml","@types/debug","@types/jest","@types/inquirer","@types/glob","@types/rimraf","@types/mime","@types/semver","@types/uuid",
];

const DATASETS = [
  { name: "single-100", workspaceCount: 1, workspace: false },
  { name: "single-500", workspaceCount: 5, workspace: true },
  { name: "mono-1000", workspaceCount: 10, workspace: true },
];

await rm(fixturesRoot, { recursive: true, force: true });
await mkdir(fixturesRoot, { recursive: true });

for (const dataset of DATASETS) {
  const datasetRoot = path.join(fixturesRoot, dataset.name);
  await mkdir(datasetRoot, { recursive: true });
  if (dataset.workspace) {
    await writeFile(
      path.join(datasetRoot, "package.json"),
      JSON.stringify(
        {
          name: `benchmark-${dataset.name}`,
          private: true,
          workspaces: ["packages/*"],
        },
        null,
        2,
      ) + "\n",
      "utf8",
    );
    const packagesRoot = path.join(datasetRoot, "packages");
    await mkdir(packagesRoot, { recursive: true });
    for (let index = 0; index < dataset.workspaceCount; index += 1) {
      const pkgRoot = path.join(packagesRoot, `pkg-${index + 1}`);
      await mkdir(pkgRoot, { recursive: true });
      await writePackageJson(pkgRoot, `${dataset.name}-pkg-${index + 1}`, index);
    }
  } else {
    await writePackageJson(datasetRoot, dataset.name, 0);
  }

  await writeFile(
    path.join(datasetRoot, "README.md"),
    [
      `# ${dataset.name}`,
      "",
      `Synthetic benchmark fixture generated by scripts/generate-benchmark-fixtures.mjs.`,
      `This dataset represents ${dataset.workspaceCount * 100} manifest dependency entries.`,
    ].join("\n") + "\n",
    "utf8",
  );
}

async function writePackageJson(dir, name, offset) {
  const dependencies = Object.fromEntries(
    PACKAGE_NAMES.slice(0, 70).map((pkg, index) => [
      PACKAGE_NAMES[(index + offset) % PACKAGE_NAMES.length],
      "^0.0.1",
    ]),
  );
  const devDependencies = Object.fromEntries(
    PACKAGE_NAMES.slice(70).map((pkg, index) => [
      PACKAGE_NAMES[(70 + index + offset) % PACKAGE_NAMES.length],
      "^0.0.1",
    ]),
  );
  await writeFile(
    path.join(dir, "package.json"),
    JSON.stringify(
      {
        name,
        private: true,
        version: "1.0.0",
        dependencies,
        devDependencies,
      },
      null,
      2,
    ) + "\n",
    "utf8",
  );
}
